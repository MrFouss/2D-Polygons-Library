######################
# A14 - LO27 PROJECT #
######################

# Created by Maxime Brodat and StÃ©phane Perrez
#
# Deadline of the project: 01/05/2015

# DESCRIPTION OF THE FILE:
# ------------------------
# This file is used to introduce some code about the unionPolygons function,
# since this function is not over.
# Indeed, the case where the polygons intersect each other is not solved yet.
# That's why we prefered not to introduce an not-finished feature in the program,
# and to put this feature in this file.

#########################
# To put in "polygon.h" #
#########################

/**
 * Computes the union between the two specified polygons
 * poly1, poly2 - the two polygons to mergeu
 */
Polygon unionPolygons (Polygon poly1, Polygon poly2);

#########################
# To put in "polygon.c" #
#########################

/**
 * Computes the union between the two specified polygons
 * poly1, poly2 - the two polygons to merge
 */
Polygon unionPolygons (Polygon p1, Polygon p2){
    Polygon resultPoly = createPolygon();
    double minLength;
    Element *closeP1, *closeP2, *tmpPointer1, *tmpPointer2;

    if(isPolygon(p1) == FALSE && isPolygon(p2) == FALSE){
    /* if both polygons are not real polygons, return an empty polygon */
    }

    else if(isPolygon(p1) == FALSE){
    /* if only the first polygon is not a real polygon, return the second one */

        tmpPointer2 = p2.head;

        do{
            resultPoly = addPoint(resultPoly, tmpPointer2->value);
            tmpPointer2 = tmpPointer2->next;
        }while(tmpPointer2 != p2.head);
    }

    else if(isPolygon(p2) == FALSE){
    /* if only the second polygon is not a real polygon, return the first one */

        tmpPointer1 = p1.head;
        do{
            resultPoly = addPoint(resultPoly, tmpPointer1->value);
            tmpPointer1 = tmpPointer1->next;
        }while(tmpPointer1 != p1.head);
    }

    else if(areEqualPolygons(p1, p2) == TRUE){
    /* if the polygons are the same, return the first one */

        tmpPointer1 = p1.head;

        do{
            resultPoly = addPoint(resultPoly, tmpPointer1->value);
            tmpPointer1 = tmpPointer1->next;
        }while(tmpPointer1 != p1.head);
    }

    else if(haveSameShapePolygons(p1,p2) == TRUE){
    /* if the polygons have the same shape, return the simplest onei (the one with the smallest amount of points) */

        if(p1.size < p2.size){
            tmpPointer1 = p1.head;

            do{
                resultPoly = addPoint(resultPoly, tmpPointer1->value);
                tmpPointer1 = tmpPointer1->next;
            }while(tmpPointer1 != p1.head);
        }

        else{
            tmpPointer1 = p2.head;

            do{
                resultPoly = addPoint(resultPoly, tmpPointer1->value);
                tmpPointer1 = tmpPointer1->next;
            }while(tmpPointer1 != p2.head);
        }
    }

    else if(isOutsidePolygon(p1,p2) && isOutsidePolygon(p2,p1)){
    /* if the polygons don't intersect each other, return p1 && p2 */

        tmpPointer1 = p1.head;
        tmpPointer2 = p2.head;
        closeP1 = p1.head;
        closeP2 = p2.head;

        minLength = lengthVector(tmpPointer1->value, tmpPointer2->value);

        /* searches the points where the two polygons are the closest */
        do{
            do{
                if(lengthVector(tmpPointer1->value, tmpPointer2->value) < minLength){
                    minLength = lengthVector(tmpPointer1->value, tmpPointer2->value);
                    closeP1 = tmpPointer1;
                    closeP2 = tmpPointer2;
                }

                tmpPointer2 = tmpPointer2->next;
            } while(tmpPointer2 != p2.head);

            tmpPointer1 = tmpPointer1->next;
        } while(tmpPointer1 != p1.head);

        tmpPointer1 = closeP1;
        tmpPointer2 = closeP2;

        do{
            resultPoly = addPoint(resultPoly, tmpPointer1->value);
            tmpPointer1 = tmpPointer1->next;
        } while(tmpPointer1 != closeP1);

        resultPoly = addPoint(resultPoly, closeP1->value);

        do{
            resultPoly = addPoint(resultPoly, tmpPointer2->value);
            tmpPointer2 = tmpPointer2->next;
        } while(tmpPointer2 != closeP2);

        resultPoly = addPoint(resultPoly, closeP2->value);
    }

    return resultPoly;
}
